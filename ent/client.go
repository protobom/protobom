// Code generated by ent, DO NOT EDIT.
// ------------------------------------------------------------------------
// SPDX-FileCopyrightText: Copyright Â© 2024 The Protobom Authors
// SPDX-FileType: SOURCE
// SPDX-License-Identifier: Apache-2.0
// ------------------------------------------------------------------------
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ------------------------------------------------------------------------
package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/bom-squad/protobom/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/bom-squad/protobom/ent/document"
	"github.com/bom-squad/protobom/ent/documenttype"
	"github.com/bom-squad/protobom/ent/edge"
	"github.com/bom-squad/protobom/ent/externalreference"
	"github.com/bom-squad/protobom/ent/hashesentry"
	"github.com/bom-squad/protobom/ent/identifiersentry"
	"github.com/bom-squad/protobom/ent/metadata"
	"github.com/bom-squad/protobom/ent/node"
	"github.com/bom-squad/protobom/ent/nodelist"
	"github.com/bom-squad/protobom/ent/person"
	"github.com/bom-squad/protobom/ent/purpose"
	"github.com/bom-squad/protobom/ent/tool"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Document is the client for interacting with the Document builders.
	Document *DocumentClient
	// DocumentType is the client for interacting with the DocumentType builders.
	DocumentType *DocumentTypeClient
	// Edge is the client for interacting with the Edge builders.
	Edge *EdgeClient
	// ExternalReference is the client for interacting with the ExternalReference builders.
	ExternalReference *ExternalReferenceClient
	// HashesEntry is the client for interacting with the HashesEntry builders.
	HashesEntry *HashesEntryClient
	// IdentifiersEntry is the client for interacting with the IdentifiersEntry builders.
	IdentifiersEntry *IdentifiersEntryClient
	// Metadata is the client for interacting with the Metadata builders.
	Metadata *MetadataClient
	// Node is the client for interacting with the Node builders.
	Node *NodeClient
	// NodeList is the client for interacting with the NodeList builders.
	NodeList *NodeListClient
	// Person is the client for interacting with the Person builders.
	Person *PersonClient
	// Purpose is the client for interacting with the Purpose builders.
	Purpose *PurposeClient
	// Tool is the client for interacting with the Tool builders.
	Tool *ToolClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Document = NewDocumentClient(c.config)
	c.DocumentType = NewDocumentTypeClient(c.config)
	c.Edge = NewEdgeClient(c.config)
	c.ExternalReference = NewExternalReferenceClient(c.config)
	c.HashesEntry = NewHashesEntryClient(c.config)
	c.IdentifiersEntry = NewIdentifiersEntryClient(c.config)
	c.Metadata = NewMetadataClient(c.config)
	c.Node = NewNodeClient(c.config)
	c.NodeList = NewNodeListClient(c.config)
	c.Person = NewPersonClient(c.config)
	c.Purpose = NewPurposeClient(c.config)
	c.Tool = NewToolClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Document:          NewDocumentClient(cfg),
		DocumentType:      NewDocumentTypeClient(cfg),
		Edge:              NewEdgeClient(cfg),
		ExternalReference: NewExternalReferenceClient(cfg),
		HashesEntry:       NewHashesEntryClient(cfg),
		IdentifiersEntry:  NewIdentifiersEntryClient(cfg),
		Metadata:          NewMetadataClient(cfg),
		Node:              NewNodeClient(cfg),
		NodeList:          NewNodeListClient(cfg),
		Person:            NewPersonClient(cfg),
		Purpose:           NewPurposeClient(cfg),
		Tool:              NewToolClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Document:          NewDocumentClient(cfg),
		DocumentType:      NewDocumentTypeClient(cfg),
		Edge:              NewEdgeClient(cfg),
		ExternalReference: NewExternalReferenceClient(cfg),
		HashesEntry:       NewHashesEntryClient(cfg),
		IdentifiersEntry:  NewIdentifiersEntryClient(cfg),
		Metadata:          NewMetadataClient(cfg),
		Node:              NewNodeClient(cfg),
		NodeList:          NewNodeListClient(cfg),
		Person:            NewPersonClient(cfg),
		Purpose:           NewPurposeClient(cfg),
		Tool:              NewToolClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Document.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Document, c.DocumentType, c.Edge, c.ExternalReference, c.HashesEntry,
		c.IdentifiersEntry, c.Metadata, c.Node, c.NodeList, c.Person, c.Purpose,
		c.Tool,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Document, c.DocumentType, c.Edge, c.ExternalReference, c.HashesEntry,
		c.IdentifiersEntry, c.Metadata, c.Node, c.NodeList, c.Person, c.Purpose,
		c.Tool,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DocumentMutation:
		return c.Document.mutate(ctx, m)
	case *DocumentTypeMutation:
		return c.DocumentType.mutate(ctx, m)
	case *EdgeMutation:
		return c.Edge.mutate(ctx, m)
	case *ExternalReferenceMutation:
		return c.ExternalReference.mutate(ctx, m)
	case *HashesEntryMutation:
		return c.HashesEntry.mutate(ctx, m)
	case *IdentifiersEntryMutation:
		return c.IdentifiersEntry.mutate(ctx, m)
	case *MetadataMutation:
		return c.Metadata.mutate(ctx, m)
	case *NodeMutation:
		return c.Node.mutate(ctx, m)
	case *NodeListMutation:
		return c.NodeList.mutate(ctx, m)
	case *PersonMutation:
		return c.Person.mutate(ctx, m)
	case *PurposeMutation:
		return c.Purpose.mutate(ctx, m)
	case *ToolMutation:
		return c.Tool.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DocumentClient is a client for the Document schema.
type DocumentClient struct {
	config
}

// NewDocumentClient returns a client for the Document from the given config.
func NewDocumentClient(c config) *DocumentClient {
	return &DocumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `document.Hooks(f(g(h())))`.
func (c *DocumentClient) Use(hooks ...Hook) {
	c.hooks.Document = append(c.hooks.Document, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `document.Intercept(f(g(h())))`.
func (c *DocumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Document = append(c.inters.Document, interceptors...)
}

// Create returns a builder for creating a Document entity.
func (c *DocumentClient) Create() *DocumentCreate {
	mutation := newDocumentMutation(c.config, OpCreate)
	return &DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Document entities.
func (c *DocumentClient) CreateBulk(builders ...*DocumentCreate) *DocumentCreateBulk {
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentClient) MapCreateBulk(slice any, setFunc func(*DocumentCreate, int)) *DocumentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentCreateBulk{err: fmt.Errorf("calling to DocumentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Document.
func (c *DocumentClient) Update() *DocumentUpdate {
	mutation := newDocumentMutation(c.config, OpUpdate)
	return &DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentClient) UpdateOne(d *Document) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocument(d))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentClient) UpdateOneID(id int) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocumentID(id))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Document.
func (c *DocumentClient) Delete() *DocumentDelete {
	mutation := newDocumentMutation(c.config, OpDelete)
	return &DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentClient) DeleteOne(d *Document) *DocumentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentClient) DeleteOneID(id int) *DocumentDeleteOne {
	builder := c.Delete().Where(document.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDeleteOne{builder}
}

// Query returns a query builder for Document.
func (c *DocumentClient) Query() *DocumentQuery {
	return &DocumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocument},
		inters: c.Interceptors(),
	}
}

// Get returns a Document entity by its id.
func (c *DocumentClient) Get(ctx context.Context, id int) (*Document, error) {
	return c.Query().Where(document.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentClient) GetX(ctx context.Context, id int) *Document {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a Document.
func (c *DocumentClient) QueryMetadata(d *Document) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, document.MetadataTable, document.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodeList queries the node_list edge of a Document.
func (c *DocumentClient) QueryNodeList(d *Document) *NodeListQuery {
	query := (&NodeListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(nodelist.Table, nodelist.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, document.NodeListTable, document.NodeListColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentClient) Hooks() []Hook {
	return c.hooks.Document
}

// Interceptors returns the client interceptors.
func (c *DocumentClient) Interceptors() []Interceptor {
	return c.inters.Document
}

func (c *DocumentClient) mutate(ctx context.Context, m *DocumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Document mutation op: %q", m.Op())
	}
}

// DocumentTypeClient is a client for the DocumentType schema.
type DocumentTypeClient struct {
	config
}

// NewDocumentTypeClient returns a client for the DocumentType from the given config.
func NewDocumentTypeClient(c config) *DocumentTypeClient {
	return &DocumentTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `documenttype.Hooks(f(g(h())))`.
func (c *DocumentTypeClient) Use(hooks ...Hook) {
	c.hooks.DocumentType = append(c.hooks.DocumentType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `documenttype.Intercept(f(g(h())))`.
func (c *DocumentTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.DocumentType = append(c.inters.DocumentType, interceptors...)
}

// Create returns a builder for creating a DocumentType entity.
func (c *DocumentTypeClient) Create() *DocumentTypeCreate {
	mutation := newDocumentTypeMutation(c.config, OpCreate)
	return &DocumentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DocumentType entities.
func (c *DocumentTypeClient) CreateBulk(builders ...*DocumentTypeCreate) *DocumentTypeCreateBulk {
	return &DocumentTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentTypeClient) MapCreateBulk(slice any, setFunc func(*DocumentTypeCreate, int)) *DocumentTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentTypeCreateBulk{err: fmt.Errorf("calling to DocumentTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DocumentType.
func (c *DocumentTypeClient) Update() *DocumentTypeUpdate {
	mutation := newDocumentTypeMutation(c.config, OpUpdate)
	return &DocumentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentTypeClient) UpdateOne(dt *DocumentType) *DocumentTypeUpdateOne {
	mutation := newDocumentTypeMutation(c.config, OpUpdateOne, withDocumentType(dt))
	return &DocumentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentTypeClient) UpdateOneID(id int) *DocumentTypeUpdateOne {
	mutation := newDocumentTypeMutation(c.config, OpUpdateOne, withDocumentTypeID(id))
	return &DocumentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DocumentType.
func (c *DocumentTypeClient) Delete() *DocumentTypeDelete {
	mutation := newDocumentTypeMutation(c.config, OpDelete)
	return &DocumentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentTypeClient) DeleteOne(dt *DocumentType) *DocumentTypeDeleteOne {
	return c.DeleteOneID(dt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentTypeClient) DeleteOneID(id int) *DocumentTypeDeleteOne {
	builder := c.Delete().Where(documenttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentTypeDeleteOne{builder}
}

// Query returns a query builder for DocumentType.
func (c *DocumentTypeClient) Query() *DocumentTypeQuery {
	return &DocumentTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocumentType},
		inters: c.Interceptors(),
	}
}

// Get returns a DocumentType entity by its id.
func (c *DocumentTypeClient) Get(ctx context.Context, id int) (*DocumentType, error) {
	return c.Query().Where(documenttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentTypeClient) GetX(ctx context.Context, id int) *DocumentType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a DocumentType.
func (c *DocumentTypeClient) QueryMetadata(dt *DocumentType) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documenttype.Table, documenttype.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, documenttype.MetadataTable, documenttype.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(dt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentTypeClient) Hooks() []Hook {
	return c.hooks.DocumentType
}

// Interceptors returns the client interceptors.
func (c *DocumentTypeClient) Interceptors() []Interceptor {
	return c.inters.DocumentType
}

func (c *DocumentTypeClient) mutate(ctx context.Context, m *DocumentTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DocumentType mutation op: %q", m.Op())
	}
}

// EdgeClient is a client for the Edge schema.
type EdgeClient struct {
	config
}

// NewEdgeClient returns a client for the Edge from the given config.
func NewEdgeClient(c config) *EdgeClient {
	return &EdgeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `edge.Hooks(f(g(h())))`.
func (c *EdgeClient) Use(hooks ...Hook) {
	c.hooks.Edge = append(c.hooks.Edge, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `edge.Intercept(f(g(h())))`.
func (c *EdgeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Edge = append(c.inters.Edge, interceptors...)
}

// Create returns a builder for creating a Edge entity.
func (c *EdgeClient) Create() *EdgeCreate {
	mutation := newEdgeMutation(c.config, OpCreate)
	return &EdgeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Edge entities.
func (c *EdgeClient) CreateBulk(builders ...*EdgeCreate) *EdgeCreateBulk {
	return &EdgeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EdgeClient) MapCreateBulk(slice any, setFunc func(*EdgeCreate, int)) *EdgeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EdgeCreateBulk{err: fmt.Errorf("calling to EdgeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EdgeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EdgeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Edge.
func (c *EdgeClient) Update() *EdgeUpdate {
	mutation := newEdgeMutation(c.config, OpUpdate)
	return &EdgeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EdgeClient) UpdateOne(e *Edge) *EdgeUpdateOne {
	mutation := newEdgeMutation(c.config, OpUpdateOne, withEdge(e))
	return &EdgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EdgeClient) UpdateOneID(id int) *EdgeUpdateOne {
	mutation := newEdgeMutation(c.config, OpUpdateOne, withEdgeID(id))
	return &EdgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Edge.
func (c *EdgeClient) Delete() *EdgeDelete {
	mutation := newEdgeMutation(c.config, OpDelete)
	return &EdgeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EdgeClient) DeleteOne(e *Edge) *EdgeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EdgeClient) DeleteOneID(id int) *EdgeDeleteOne {
	builder := c.Delete().Where(edge.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EdgeDeleteOne{builder}
}

// Query returns a query builder for Edge.
func (c *EdgeClient) Query() *EdgeQuery {
	return &EdgeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEdge},
		inters: c.Interceptors(),
	}
}

// Get returns a Edge entity by its id.
func (c *EdgeClient) Get(ctx context.Context, id int) (*Edge, error) {
	return c.Query().Where(edge.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EdgeClient) GetX(ctx context.Context, id int) *Edge {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNodeList queries the node_list edge of a Edge.
func (c *EdgeClient) QueryNodeList(e *Edge) *NodeListQuery {
	query := (&NodeListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(edge.Table, edge.FieldID, id),
			sqlgraph.To(nodelist.Table, nodelist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, edge.NodeListTable, edge.NodeListColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EdgeClient) Hooks() []Hook {
	return c.hooks.Edge
}

// Interceptors returns the client interceptors.
func (c *EdgeClient) Interceptors() []Interceptor {
	return c.inters.Edge
}

func (c *EdgeClient) mutate(ctx context.Context, m *EdgeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EdgeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EdgeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EdgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EdgeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Edge mutation op: %q", m.Op())
	}
}

// ExternalReferenceClient is a client for the ExternalReference schema.
type ExternalReferenceClient struct {
	config
}

// NewExternalReferenceClient returns a client for the ExternalReference from the given config.
func NewExternalReferenceClient(c config) *ExternalReferenceClient {
	return &ExternalReferenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `externalreference.Hooks(f(g(h())))`.
func (c *ExternalReferenceClient) Use(hooks ...Hook) {
	c.hooks.ExternalReference = append(c.hooks.ExternalReference, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `externalreference.Intercept(f(g(h())))`.
func (c *ExternalReferenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExternalReference = append(c.inters.ExternalReference, interceptors...)
}

// Create returns a builder for creating a ExternalReference entity.
func (c *ExternalReferenceClient) Create() *ExternalReferenceCreate {
	mutation := newExternalReferenceMutation(c.config, OpCreate)
	return &ExternalReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExternalReference entities.
func (c *ExternalReferenceClient) CreateBulk(builders ...*ExternalReferenceCreate) *ExternalReferenceCreateBulk {
	return &ExternalReferenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExternalReferenceClient) MapCreateBulk(slice any, setFunc func(*ExternalReferenceCreate, int)) *ExternalReferenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExternalReferenceCreateBulk{err: fmt.Errorf("calling to ExternalReferenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExternalReferenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExternalReferenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExternalReference.
func (c *ExternalReferenceClient) Update() *ExternalReferenceUpdate {
	mutation := newExternalReferenceMutation(c.config, OpUpdate)
	return &ExternalReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExternalReferenceClient) UpdateOne(er *ExternalReference) *ExternalReferenceUpdateOne {
	mutation := newExternalReferenceMutation(c.config, OpUpdateOne, withExternalReference(er))
	return &ExternalReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExternalReferenceClient) UpdateOneID(id int) *ExternalReferenceUpdateOne {
	mutation := newExternalReferenceMutation(c.config, OpUpdateOne, withExternalReferenceID(id))
	return &ExternalReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExternalReference.
func (c *ExternalReferenceClient) Delete() *ExternalReferenceDelete {
	mutation := newExternalReferenceMutation(c.config, OpDelete)
	return &ExternalReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExternalReferenceClient) DeleteOne(er *ExternalReference) *ExternalReferenceDeleteOne {
	return c.DeleteOneID(er.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExternalReferenceClient) DeleteOneID(id int) *ExternalReferenceDeleteOne {
	builder := c.Delete().Where(externalreference.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExternalReferenceDeleteOne{builder}
}

// Query returns a query builder for ExternalReference.
func (c *ExternalReferenceClient) Query() *ExternalReferenceQuery {
	return &ExternalReferenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExternalReference},
		inters: c.Interceptors(),
	}
}

// Get returns a ExternalReference entity by its id.
func (c *ExternalReferenceClient) Get(ctx context.Context, id int) (*ExternalReference, error) {
	return c.Query().Where(externalreference.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExternalReferenceClient) GetX(ctx context.Context, id int) *ExternalReference {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHashes queries the hashes edge of a ExternalReference.
func (c *ExternalReferenceClient) QueryHashes(er *ExternalReference) *HashesEntryQuery {
	query := (&HashesEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(externalreference.Table, externalreference.FieldID, id),
			sqlgraph.To(hashesentry.Table, hashesentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, externalreference.HashesTable, externalreference.HashesColumn),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a ExternalReference.
func (c *ExternalReferenceClient) QueryNodes(er *ExternalReference) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(externalreference.Table, externalreference.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, externalreference.NodesTable, externalreference.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExternalReferenceClient) Hooks() []Hook {
	return c.hooks.ExternalReference
}

// Interceptors returns the client interceptors.
func (c *ExternalReferenceClient) Interceptors() []Interceptor {
	return c.inters.ExternalReference
}

func (c *ExternalReferenceClient) mutate(ctx context.Context, m *ExternalReferenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExternalReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExternalReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExternalReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExternalReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExternalReference mutation op: %q", m.Op())
	}
}

// HashesEntryClient is a client for the HashesEntry schema.
type HashesEntryClient struct {
	config
}

// NewHashesEntryClient returns a client for the HashesEntry from the given config.
func NewHashesEntryClient(c config) *HashesEntryClient {
	return &HashesEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hashesentry.Hooks(f(g(h())))`.
func (c *HashesEntryClient) Use(hooks ...Hook) {
	c.hooks.HashesEntry = append(c.hooks.HashesEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hashesentry.Intercept(f(g(h())))`.
func (c *HashesEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.HashesEntry = append(c.inters.HashesEntry, interceptors...)
}

// Create returns a builder for creating a HashesEntry entity.
func (c *HashesEntryClient) Create() *HashesEntryCreate {
	mutation := newHashesEntryMutation(c.config, OpCreate)
	return &HashesEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HashesEntry entities.
func (c *HashesEntryClient) CreateBulk(builders ...*HashesEntryCreate) *HashesEntryCreateBulk {
	return &HashesEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HashesEntryClient) MapCreateBulk(slice any, setFunc func(*HashesEntryCreate, int)) *HashesEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HashesEntryCreateBulk{err: fmt.Errorf("calling to HashesEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HashesEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HashesEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HashesEntry.
func (c *HashesEntryClient) Update() *HashesEntryUpdate {
	mutation := newHashesEntryMutation(c.config, OpUpdate)
	return &HashesEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HashesEntryClient) UpdateOne(he *HashesEntry) *HashesEntryUpdateOne {
	mutation := newHashesEntryMutation(c.config, OpUpdateOne, withHashesEntry(he))
	return &HashesEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HashesEntryClient) UpdateOneID(id int) *HashesEntryUpdateOne {
	mutation := newHashesEntryMutation(c.config, OpUpdateOne, withHashesEntryID(id))
	return &HashesEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HashesEntry.
func (c *HashesEntryClient) Delete() *HashesEntryDelete {
	mutation := newHashesEntryMutation(c.config, OpDelete)
	return &HashesEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HashesEntryClient) DeleteOne(he *HashesEntry) *HashesEntryDeleteOne {
	return c.DeleteOneID(he.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HashesEntryClient) DeleteOneID(id int) *HashesEntryDeleteOne {
	builder := c.Delete().Where(hashesentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HashesEntryDeleteOne{builder}
}

// Query returns a query builder for HashesEntry.
func (c *HashesEntryClient) Query() *HashesEntryQuery {
	return &HashesEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHashesEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a HashesEntry entity by its id.
func (c *HashesEntryClient) Get(ctx context.Context, id int) (*HashesEntry, error) {
	return c.Query().Where(hashesentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HashesEntryClient) GetX(ctx context.Context, id int) *HashesEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExternalReferences queries the external_references edge of a HashesEntry.
func (c *HashesEntryClient) QueryExternalReferences(he *HashesEntry) *ExternalReferenceQuery {
	query := (&ExternalReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashesentry.Table, hashesentry.FieldID, id),
			sqlgraph.To(externalreference.Table, externalreference.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hashesentry.ExternalReferencesTable, hashesentry.ExternalReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a HashesEntry.
func (c *HashesEntryClient) QueryNodes(he *HashesEntry) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashesentry.Table, hashesentry.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hashesentry.NodesTable, hashesentry.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HashesEntryClient) Hooks() []Hook {
	return c.hooks.HashesEntry
}

// Interceptors returns the client interceptors.
func (c *HashesEntryClient) Interceptors() []Interceptor {
	return c.inters.HashesEntry
}

func (c *HashesEntryClient) mutate(ctx context.Context, m *HashesEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HashesEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HashesEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HashesEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HashesEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HashesEntry mutation op: %q", m.Op())
	}
}

// IdentifiersEntryClient is a client for the IdentifiersEntry schema.
type IdentifiersEntryClient struct {
	config
}

// NewIdentifiersEntryClient returns a client for the IdentifiersEntry from the given config.
func NewIdentifiersEntryClient(c config) *IdentifiersEntryClient {
	return &IdentifiersEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `identifiersentry.Hooks(f(g(h())))`.
func (c *IdentifiersEntryClient) Use(hooks ...Hook) {
	c.hooks.IdentifiersEntry = append(c.hooks.IdentifiersEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `identifiersentry.Intercept(f(g(h())))`.
func (c *IdentifiersEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.IdentifiersEntry = append(c.inters.IdentifiersEntry, interceptors...)
}

// Create returns a builder for creating a IdentifiersEntry entity.
func (c *IdentifiersEntryClient) Create() *IdentifiersEntryCreate {
	mutation := newIdentifiersEntryMutation(c.config, OpCreate)
	return &IdentifiersEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IdentifiersEntry entities.
func (c *IdentifiersEntryClient) CreateBulk(builders ...*IdentifiersEntryCreate) *IdentifiersEntryCreateBulk {
	return &IdentifiersEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IdentifiersEntryClient) MapCreateBulk(slice any, setFunc func(*IdentifiersEntryCreate, int)) *IdentifiersEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IdentifiersEntryCreateBulk{err: fmt.Errorf("calling to IdentifiersEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IdentifiersEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IdentifiersEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IdentifiersEntry.
func (c *IdentifiersEntryClient) Update() *IdentifiersEntryUpdate {
	mutation := newIdentifiersEntryMutation(c.config, OpUpdate)
	return &IdentifiersEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IdentifiersEntryClient) UpdateOne(ie *IdentifiersEntry) *IdentifiersEntryUpdateOne {
	mutation := newIdentifiersEntryMutation(c.config, OpUpdateOne, withIdentifiersEntry(ie))
	return &IdentifiersEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IdentifiersEntryClient) UpdateOneID(id int) *IdentifiersEntryUpdateOne {
	mutation := newIdentifiersEntryMutation(c.config, OpUpdateOne, withIdentifiersEntryID(id))
	return &IdentifiersEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IdentifiersEntry.
func (c *IdentifiersEntryClient) Delete() *IdentifiersEntryDelete {
	mutation := newIdentifiersEntryMutation(c.config, OpDelete)
	return &IdentifiersEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IdentifiersEntryClient) DeleteOne(ie *IdentifiersEntry) *IdentifiersEntryDeleteOne {
	return c.DeleteOneID(ie.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IdentifiersEntryClient) DeleteOneID(id int) *IdentifiersEntryDeleteOne {
	builder := c.Delete().Where(identifiersentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IdentifiersEntryDeleteOne{builder}
}

// Query returns a query builder for IdentifiersEntry.
func (c *IdentifiersEntryClient) Query() *IdentifiersEntryQuery {
	return &IdentifiersEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIdentifiersEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a IdentifiersEntry entity by its id.
func (c *IdentifiersEntryClient) Get(ctx context.Context, id int) (*IdentifiersEntry, error) {
	return c.Query().Where(identifiersentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IdentifiersEntryClient) GetX(ctx context.Context, id int) *IdentifiersEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNodes queries the nodes edge of a IdentifiersEntry.
func (c *IdentifiersEntryClient) QueryNodes(ie *IdentifiersEntry) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(identifiersentry.Table, identifiersentry.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, identifiersentry.NodesTable, identifiersentry.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IdentifiersEntryClient) Hooks() []Hook {
	return c.hooks.IdentifiersEntry
}

// Interceptors returns the client interceptors.
func (c *IdentifiersEntryClient) Interceptors() []Interceptor {
	return c.inters.IdentifiersEntry
}

func (c *IdentifiersEntryClient) mutate(ctx context.Context, m *IdentifiersEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IdentifiersEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IdentifiersEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IdentifiersEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IdentifiersEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IdentifiersEntry mutation op: %q", m.Op())
	}
}

// MetadataClient is a client for the Metadata schema.
type MetadataClient struct {
	config
}

// NewMetadataClient returns a client for the Metadata from the given config.
func NewMetadataClient(c config) *MetadataClient {
	return &MetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadata.Hooks(f(g(h())))`.
func (c *MetadataClient) Use(hooks ...Hook) {
	c.hooks.Metadata = append(c.hooks.Metadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metadata.Intercept(f(g(h())))`.
func (c *MetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.Metadata = append(c.inters.Metadata, interceptors...)
}

// Create returns a builder for creating a Metadata entity.
func (c *MetadataClient) Create() *MetadataCreate {
	mutation := newMetadataMutation(c.config, OpCreate)
	return &MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metadata entities.
func (c *MetadataClient) CreateBulk(builders ...*MetadataCreate) *MetadataCreateBulk {
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MetadataClient) MapCreateBulk(slice any, setFunc func(*MetadataCreate, int)) *MetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MetadataCreateBulk{err: fmt.Errorf("calling to MetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metadata.
func (c *MetadataClient) Update() *MetadataUpdate {
	mutation := newMetadataMutation(c.config, OpUpdate)
	return &MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetadataClient) UpdateOne(m *Metadata) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadata(m))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetadataClient) UpdateOneID(id string) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadataID(id))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metadata.
func (c *MetadataClient) Delete() *MetadataDelete {
	mutation := newMetadataMutation(c.config, OpDelete)
	return &MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetadataClient) DeleteOne(m *Metadata) *MetadataDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetadataClient) DeleteOneID(id string) *MetadataDeleteOne {
	builder := c.Delete().Where(metadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetadataDeleteOne{builder}
}

// Query returns a query builder for Metadata.
func (c *MetadataClient) Query() *MetadataQuery {
	return &MetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a Metadata entity by its id.
func (c *MetadataClient) Get(ctx context.Context, id string) (*Metadata, error) {
	return c.Query().Where(metadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetadataClient) GetX(ctx context.Context, id string) *Metadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTools queries the tools edge of a Metadata.
func (c *MetadataClient) QueryTools(m *Metadata) *ToolQuery {
	query := (&ToolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(tool.Table, tool.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metadata.ToolsTable, metadata.ToolsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthors queries the authors edge of a Metadata.
func (c *MetadataClient) QueryAuthors(m *Metadata) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metadata.AuthorsTable, metadata.AuthorsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocumentTypes queries the document_types edge of a Metadata.
func (c *MetadataClient) QueryDocumentTypes(m *Metadata) *DocumentTypeQuery {
	query := (&DocumentTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(documenttype.Table, documenttype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metadata.DocumentTypesTable, metadata.DocumentTypesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocument queries the document edge of a Metadata.
func (c *MetadataClient) QueryDocument(m *Metadata) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metadata.DocumentTable, metadata.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetadataClient) Hooks() []Hook {
	return c.hooks.Metadata
}

// Interceptors returns the client interceptors.
func (c *MetadataClient) Interceptors() []Interceptor {
	return c.inters.Metadata
}

func (c *MetadataClient) mutate(ctx context.Context, m *MetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Metadata mutation op: %q", m.Op())
	}
}

// NodeClient is a client for the Node schema.
type NodeClient struct {
	config
}

// NewNodeClient returns a client for the Node from the given config.
func NewNodeClient(c config) *NodeClient {
	return &NodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `node.Hooks(f(g(h())))`.
func (c *NodeClient) Use(hooks ...Hook) {
	c.hooks.Node = append(c.hooks.Node, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `node.Intercept(f(g(h())))`.
func (c *NodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Node = append(c.inters.Node, interceptors...)
}

// Create returns a builder for creating a Node entity.
func (c *NodeClient) Create() *NodeCreate {
	mutation := newNodeMutation(c.config, OpCreate)
	return &NodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Node entities.
func (c *NodeClient) CreateBulk(builders ...*NodeCreate) *NodeCreateBulk {
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NodeClient) MapCreateBulk(slice any, setFunc func(*NodeCreate, int)) *NodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NodeCreateBulk{err: fmt.Errorf("calling to NodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Node.
func (c *NodeClient) Update() *NodeUpdate {
	mutation := newNodeMutation(c.config, OpUpdate)
	return &NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodeClient) UpdateOne(n *Node) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNode(n))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodeClient) UpdateOneID(id string) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNodeID(id))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Node.
func (c *NodeClient) Delete() *NodeDelete {
	mutation := newNodeMutation(c.config, OpDelete)
	return &NodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodeClient) DeleteOne(n *Node) *NodeDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodeClient) DeleteOneID(id string) *NodeDeleteOne {
	builder := c.Delete().Where(node.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodeDeleteOne{builder}
}

// Query returns a query builder for Node.
func (c *NodeClient) Query() *NodeQuery {
	return &NodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNode},
		inters: c.Interceptors(),
	}
}

// Get returns a Node entity by its id.
func (c *NodeClient) Get(ctx context.Context, id string) (*Node, error) {
	return c.Query().Where(node.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodeClient) GetX(ctx context.Context, id string) *Node {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySuppliers queries the suppliers edge of a Node.
func (c *NodeClient) QuerySuppliers(n *Node) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.SuppliersTable, node.SuppliersColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOriginators queries the originators edge of a Node.
func (c *NodeClient) QueryOriginators(n *Node) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.OriginatorsTable, node.OriginatorsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExternalReferences queries the external_references edge of a Node.
func (c *NodeClient) QueryExternalReferences(n *Node) *ExternalReferenceQuery {
	query := (&ExternalReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(externalreference.Table, externalreference.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.ExternalReferencesTable, node.ExternalReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIdentifiers queries the identifiers edge of a Node.
func (c *NodeClient) QueryIdentifiers(n *Node) *IdentifiersEntryQuery {
	query := (&IdentifiersEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(identifiersentry.Table, identifiersentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.IdentifiersTable, node.IdentifiersColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHashes queries the hashes edge of a Node.
func (c *NodeClient) QueryHashes(n *Node) *HashesEntryQuery {
	query := (&HashesEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(hashesentry.Table, hashesentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.HashesTable, node.HashesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryPurpose queries the primary_purpose edge of a Node.
func (c *NodeClient) QueryPrimaryPurpose(n *Node) *PurposeQuery {
	query := (&PurposeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(purpose.Table, purpose.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, node.PrimaryPurposeTable, node.PrimaryPurposePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodeList queries the node_list edge of a Node.
func (c *NodeClient) QueryNodeList(n *Node) *NodeListQuery {
	query := (&NodeListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(nodelist.Table, nodelist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, node.NodeListTable, node.NodeListColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodeClient) Hooks() []Hook {
	return c.hooks.Node
}

// Interceptors returns the client interceptors.
func (c *NodeClient) Interceptors() []Interceptor {
	return c.inters.Node
}

func (c *NodeClient) mutate(ctx context.Context, m *NodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Node mutation op: %q", m.Op())
	}
}

// NodeListClient is a client for the NodeList schema.
type NodeListClient struct {
	config
}

// NewNodeListClient returns a client for the NodeList from the given config.
func NewNodeListClient(c config) *NodeListClient {
	return &NodeListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nodelist.Hooks(f(g(h())))`.
func (c *NodeListClient) Use(hooks ...Hook) {
	c.hooks.NodeList = append(c.hooks.NodeList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nodelist.Intercept(f(g(h())))`.
func (c *NodeListClient) Intercept(interceptors ...Interceptor) {
	c.inters.NodeList = append(c.inters.NodeList, interceptors...)
}

// Create returns a builder for creating a NodeList entity.
func (c *NodeListClient) Create() *NodeListCreate {
	mutation := newNodeListMutation(c.config, OpCreate)
	return &NodeListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NodeList entities.
func (c *NodeListClient) CreateBulk(builders ...*NodeListCreate) *NodeListCreateBulk {
	return &NodeListCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NodeListClient) MapCreateBulk(slice any, setFunc func(*NodeListCreate, int)) *NodeListCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NodeListCreateBulk{err: fmt.Errorf("calling to NodeListClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NodeListCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NodeListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NodeList.
func (c *NodeListClient) Update() *NodeListUpdate {
	mutation := newNodeListMutation(c.config, OpUpdate)
	return &NodeListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodeListClient) UpdateOne(nl *NodeList) *NodeListUpdateOne {
	mutation := newNodeListMutation(c.config, OpUpdateOne, withNodeList(nl))
	return &NodeListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodeListClient) UpdateOneID(id int) *NodeListUpdateOne {
	mutation := newNodeListMutation(c.config, OpUpdateOne, withNodeListID(id))
	return &NodeListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NodeList.
func (c *NodeListClient) Delete() *NodeListDelete {
	mutation := newNodeListMutation(c.config, OpDelete)
	return &NodeListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodeListClient) DeleteOne(nl *NodeList) *NodeListDeleteOne {
	return c.DeleteOneID(nl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodeListClient) DeleteOneID(id int) *NodeListDeleteOne {
	builder := c.Delete().Where(nodelist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodeListDeleteOne{builder}
}

// Query returns a query builder for NodeList.
func (c *NodeListClient) Query() *NodeListQuery {
	return &NodeListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNodeList},
		inters: c.Interceptors(),
	}
}

// Get returns a NodeList entity by its id.
func (c *NodeListClient) Get(ctx context.Context, id int) (*NodeList, error) {
	return c.Query().Where(nodelist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodeListClient) GetX(ctx context.Context, id int) *NodeList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNodes queries the nodes edge of a NodeList.
func (c *NodeListClient) QueryNodes(nl *NodeList) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodelist.Table, nodelist.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, nodelist.NodesTable, nodelist.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(nl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEdges queries the edges edge of a NodeList.
func (c *NodeListClient) QueryEdges(nl *NodeList) *EdgeQuery {
	query := (&EdgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodelist.Table, nodelist.FieldID, id),
			sqlgraph.To(edge.Table, edge.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, nodelist.EdgesTable, nodelist.EdgesColumn),
		)
		fromV = sqlgraph.Neighbors(nl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocument queries the document edge of a NodeList.
func (c *NodeListClient) QueryDocument(nl *NodeList) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodelist.Table, nodelist.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, nodelist.DocumentTable, nodelist.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(nl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodeListClient) Hooks() []Hook {
	return c.hooks.NodeList
}

// Interceptors returns the client interceptors.
func (c *NodeListClient) Interceptors() []Interceptor {
	return c.inters.NodeList
}

func (c *NodeListClient) mutate(ctx context.Context, m *NodeListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodeListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodeListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodeListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodeListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NodeList mutation op: %q", m.Op())
	}
}

// PersonClient is a client for the Person schema.
type PersonClient struct {
	config
}

// NewPersonClient returns a client for the Person from the given config.
func NewPersonClient(c config) *PersonClient {
	return &PersonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `person.Hooks(f(g(h())))`.
func (c *PersonClient) Use(hooks ...Hook) {
	c.hooks.Person = append(c.hooks.Person, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `person.Intercept(f(g(h())))`.
func (c *PersonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Person = append(c.inters.Person, interceptors...)
}

// Create returns a builder for creating a Person entity.
func (c *PersonClient) Create() *PersonCreate {
	mutation := newPersonMutation(c.config, OpCreate)
	return &PersonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Person entities.
func (c *PersonClient) CreateBulk(builders ...*PersonCreate) *PersonCreateBulk {
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonClient) MapCreateBulk(slice any, setFunc func(*PersonCreate, int)) *PersonCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonCreateBulk{err: fmt.Errorf("calling to PersonClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Person.
func (c *PersonClient) Update() *PersonUpdate {
	mutation := newPersonMutation(c.config, OpUpdate)
	return &PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonClient) UpdateOne(pe *Person) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPerson(pe))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonClient) UpdateOneID(id int) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPersonID(id))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Person.
func (c *PersonClient) Delete() *PersonDelete {
	mutation := newPersonMutation(c.config, OpDelete)
	return &PersonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonClient) DeleteOne(pe *Person) *PersonDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonClient) DeleteOneID(id int) *PersonDeleteOne {
	builder := c.Delete().Where(person.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonDeleteOne{builder}
}

// Query returns a query builder for Person.
func (c *PersonClient) Query() *PersonQuery {
	return &PersonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerson},
		inters: c.Interceptors(),
	}
}

// Get returns a Person entity by its id.
func (c *PersonClient) Get(ctx context.Context, id int) (*Person, error) {
	return c.Query().Where(person.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonClient) GetX(ctx context.Context, id int) *Person {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContactOwner queries the contact_owner edge of a Person.
func (c *PersonClient) QueryContactOwner(pe *Person) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, person.ContactOwnerTable, person.ContactOwnerColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContacts queries the contacts edge of a Person.
func (c *PersonClient) QueryContacts(pe *Person) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.ContactsTable, person.ContactsColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Person.
func (c *PersonClient) QueryMetadata(pe *Person) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, person.MetadataTable, person.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNode queries the node edge of a Person.
func (c *PersonClient) QueryNode(pe *Person) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, person.NodeTable, person.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonClient) Hooks() []Hook {
	return c.hooks.Person
}

// Interceptors returns the client interceptors.
func (c *PersonClient) Interceptors() []Interceptor {
	return c.inters.Person
}

func (c *PersonClient) mutate(ctx context.Context, m *PersonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Person mutation op: %q", m.Op())
	}
}

// PurposeClient is a client for the Purpose schema.
type PurposeClient struct {
	config
}

// NewPurposeClient returns a client for the Purpose from the given config.
func NewPurposeClient(c config) *PurposeClient {
	return &PurposeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `purpose.Hooks(f(g(h())))`.
func (c *PurposeClient) Use(hooks ...Hook) {
	c.hooks.Purpose = append(c.hooks.Purpose, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `purpose.Intercept(f(g(h())))`.
func (c *PurposeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Purpose = append(c.inters.Purpose, interceptors...)
}

// Create returns a builder for creating a Purpose entity.
func (c *PurposeClient) Create() *PurposeCreate {
	mutation := newPurposeMutation(c.config, OpCreate)
	return &PurposeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Purpose entities.
func (c *PurposeClient) CreateBulk(builders ...*PurposeCreate) *PurposeCreateBulk {
	return &PurposeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PurposeClient) MapCreateBulk(slice any, setFunc func(*PurposeCreate, int)) *PurposeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PurposeCreateBulk{err: fmt.Errorf("calling to PurposeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PurposeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PurposeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Purpose.
func (c *PurposeClient) Update() *PurposeUpdate {
	mutation := newPurposeMutation(c.config, OpUpdate)
	return &PurposeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PurposeClient) UpdateOne(pu *Purpose) *PurposeUpdateOne {
	mutation := newPurposeMutation(c.config, OpUpdateOne, withPurpose(pu))
	return &PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PurposeClient) UpdateOneID(id int) *PurposeUpdateOne {
	mutation := newPurposeMutation(c.config, OpUpdateOne, withPurposeID(id))
	return &PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Purpose.
func (c *PurposeClient) Delete() *PurposeDelete {
	mutation := newPurposeMutation(c.config, OpDelete)
	return &PurposeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PurposeClient) DeleteOne(pu *Purpose) *PurposeDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PurposeClient) DeleteOneID(id int) *PurposeDeleteOne {
	builder := c.Delete().Where(purpose.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PurposeDeleteOne{builder}
}

// Query returns a query builder for Purpose.
func (c *PurposeClient) Query() *PurposeQuery {
	return &PurposeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePurpose},
		inters: c.Interceptors(),
	}
}

// Get returns a Purpose entity by its id.
func (c *PurposeClient) Get(ctx context.Context, id int) (*Purpose, error) {
	return c.Query().Where(purpose.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PurposeClient) GetX(ctx context.Context, id int) *Purpose {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNode queries the node edge of a Purpose.
func (c *PurposeClient) QueryNode(pu *Purpose) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(purpose.Table, purpose.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, purpose.NodeTable, purpose.NodePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PurposeClient) Hooks() []Hook {
	return c.hooks.Purpose
}

// Interceptors returns the client interceptors.
func (c *PurposeClient) Interceptors() []Interceptor {
	return c.inters.Purpose
}

func (c *PurposeClient) mutate(ctx context.Context, m *PurposeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PurposeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PurposeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PurposeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Purpose mutation op: %q", m.Op())
	}
}

// ToolClient is a client for the Tool schema.
type ToolClient struct {
	config
}

// NewToolClient returns a client for the Tool from the given config.
func NewToolClient(c config) *ToolClient {
	return &ToolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tool.Hooks(f(g(h())))`.
func (c *ToolClient) Use(hooks ...Hook) {
	c.hooks.Tool = append(c.hooks.Tool, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tool.Intercept(f(g(h())))`.
func (c *ToolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tool = append(c.inters.Tool, interceptors...)
}

// Create returns a builder for creating a Tool entity.
func (c *ToolClient) Create() *ToolCreate {
	mutation := newToolMutation(c.config, OpCreate)
	return &ToolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tool entities.
func (c *ToolClient) CreateBulk(builders ...*ToolCreate) *ToolCreateBulk {
	return &ToolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ToolClient) MapCreateBulk(slice any, setFunc func(*ToolCreate, int)) *ToolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ToolCreateBulk{err: fmt.Errorf("calling to ToolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ToolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ToolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tool.
func (c *ToolClient) Update() *ToolUpdate {
	mutation := newToolMutation(c.config, OpUpdate)
	return &ToolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ToolClient) UpdateOne(t *Tool) *ToolUpdateOne {
	mutation := newToolMutation(c.config, OpUpdateOne, withTool(t))
	return &ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ToolClient) UpdateOneID(id int) *ToolUpdateOne {
	mutation := newToolMutation(c.config, OpUpdateOne, withToolID(id))
	return &ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tool.
func (c *ToolClient) Delete() *ToolDelete {
	mutation := newToolMutation(c.config, OpDelete)
	return &ToolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ToolClient) DeleteOne(t *Tool) *ToolDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ToolClient) DeleteOneID(id int) *ToolDeleteOne {
	builder := c.Delete().Where(tool.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ToolDeleteOne{builder}
}

// Query returns a query builder for Tool.
func (c *ToolClient) Query() *ToolQuery {
	return &ToolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTool},
		inters: c.Interceptors(),
	}
}

// Get returns a Tool entity by its id.
func (c *ToolClient) Get(ctx context.Context, id int) (*Tool, error) {
	return c.Query().Where(tool.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ToolClient) GetX(ctx context.Context, id int) *Tool {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a Tool.
func (c *ToolClient) QueryMetadata(t *Tool) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tool.Table, tool.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tool.MetadataTable, tool.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ToolClient) Hooks() []Hook {
	return c.hooks.Tool
}

// Interceptors returns the client interceptors.
func (c *ToolClient) Interceptors() []Interceptor {
	return c.inters.Tool
}

func (c *ToolClient) mutate(ctx context.Context, m *ToolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ToolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ToolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ToolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tool mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Document, DocumentType, Edge, ExternalReference, HashesEntry, IdentifiersEntry,
		Metadata, Node, NodeList, Person, Purpose, Tool []ent.Hook
	}
	inters struct {
		Document, DocumentType, Edge, ExternalReference, HashesEntry, IdentifiersEntry,
		Metadata, Node, NodeList, Person, Purpose, Tool []ent.Interceptor
	}
)
