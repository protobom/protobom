// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/bom-squad/protobom/pkg/sbom/ent/node"
)

// Node is the model entity for the Node schema.
type Node struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Type holds the value of the "type" field.
	Type node.Type `json:"type,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// FileName holds the value of the "file_name" field.
	FileName string `json:"file_name,omitempty"`
	// URLHome holds the value of the "url_home" field.
	URLHome string `json:"url_home,omitempty"`
	// URLDownload holds the value of the "url_download" field.
	URLDownload string `json:"url_download,omitempty"`
	// Licenses holds the value of the "licenses" field.
	Licenses string `json:"licenses,omitempty"`
	// LicenseConcluded holds the value of the "license_concluded" field.
	LicenseConcluded string `json:"license_concluded,omitempty"`
	// LicenseComments holds the value of the "license_comments" field.
	LicenseComments string `json:"license_comments,omitempty"`
	// Copyright holds the value of the "copyright" field.
	Copyright string `json:"copyright,omitempty"`
	// SourceInfo holds the value of the "source_info" field.
	SourceInfo string `json:"source_info,omitempty"`
	// Comment holds the value of the "comment" field.
	Comment string `json:"comment,omitempty"`
	// Summary holds the value of the "summary" field.
	Summary string `json:"summary,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Attribution holds the value of the "attribution" field.
	Attribution string `json:"attribution,omitempty"`
	// FileTypes holds the value of the "file_types" field.
	FileTypes string `json:"file_types,omitempty"`
	// PrimaryPurpose holds the value of the "primary_purpose" field.
	PrimaryPurpose node.PrimaryPurpose `json:"primary_purpose,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the NodeQuery when eager-loading is set.
	Edges           NodeEdges `json:"edges"`
	node_list_nodes *int
	selectValues    sql.SelectValues
}

// NodeEdges holds the relations/edges for other nodes in the graph.
type NodeEdges struct {
	// Suppliers holds the value of the suppliers edge.
	Suppliers []*Person `json:"suppliers,omitempty"`
	// Originators holds the value of the originators edge.
	Originators []*Person `json:"originators,omitempty"`
	// ExternalReferences holds the value of the external_references edge.
	ExternalReferences []*ExternalReference `json:"external_references,omitempty"`
	// Identifiers holds the value of the identifiers edge.
	Identifiers []*IdentifiersEntry `json:"identifiers,omitempty"`
	// Hashes holds the value of the hashes edge.
	Hashes []*HashesEntry `json:"hashes,omitempty"`
	// ReleaseDate holds the value of the release_date edge.
	ReleaseDate []*Timestamp `json:"release_date,omitempty"`
	// BuildDate holds the value of the build_date edge.
	BuildDate []*Timestamp `json:"build_date,omitempty"`
	// ValidUntilDate holds the value of the valid_until_date edge.
	ValidUntilDate []*Timestamp `json:"valid_until_date,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [8]bool
}

// SuppliersOrErr returns the Suppliers value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) SuppliersOrErr() ([]*Person, error) {
	if e.loadedTypes[0] {
		return e.Suppliers, nil
	}
	return nil, &NotLoadedError{edge: "suppliers"}
}

// OriginatorsOrErr returns the Originators value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) OriginatorsOrErr() ([]*Person, error) {
	if e.loadedTypes[1] {
		return e.Originators, nil
	}
	return nil, &NotLoadedError{edge: "originators"}
}

// ExternalReferencesOrErr returns the ExternalReferences value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) ExternalReferencesOrErr() ([]*ExternalReference, error) {
	if e.loadedTypes[2] {
		return e.ExternalReferences, nil
	}
	return nil, &NotLoadedError{edge: "external_references"}
}

// IdentifiersOrErr returns the Identifiers value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) IdentifiersOrErr() ([]*IdentifiersEntry, error) {
	if e.loadedTypes[3] {
		return e.Identifiers, nil
	}
	return nil, &NotLoadedError{edge: "identifiers"}
}

// HashesOrErr returns the Hashes value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) HashesOrErr() ([]*HashesEntry, error) {
	if e.loadedTypes[4] {
		return e.Hashes, nil
	}
	return nil, &NotLoadedError{edge: "hashes"}
}

// ReleaseDateOrErr returns the ReleaseDate value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) ReleaseDateOrErr() ([]*Timestamp, error) {
	if e.loadedTypes[5] {
		return e.ReleaseDate, nil
	}
	return nil, &NotLoadedError{edge: "release_date"}
}

// BuildDateOrErr returns the BuildDate value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) BuildDateOrErr() ([]*Timestamp, error) {
	if e.loadedTypes[6] {
		return e.BuildDate, nil
	}
	return nil, &NotLoadedError{edge: "build_date"}
}

// ValidUntilDateOrErr returns the ValidUntilDate value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) ValidUntilDateOrErr() ([]*Timestamp, error) {
	if e.loadedTypes[7] {
		return e.ValidUntilDate, nil
	}
	return nil, &NotLoadedError{edge: "valid_until_date"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Node) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case node.FieldID, node.FieldType, node.FieldName, node.FieldVersion, node.FieldFileName, node.FieldURLHome, node.FieldURLDownload, node.FieldLicenses, node.FieldLicenseConcluded, node.FieldLicenseComments, node.FieldCopyright, node.FieldSourceInfo, node.FieldComment, node.FieldSummary, node.FieldDescription, node.FieldAttribution, node.FieldFileTypes, node.FieldPrimaryPurpose:
			values[i] = new(sql.NullString)
		case node.ForeignKeys[0]: // node_list_nodes
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Node fields.
func (n *Node) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case node.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				n.ID = value.String
			}
		case node.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				n.Type = node.Type(value.String)
			}
		case node.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				n.Name = value.String
			}
		case node.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				n.Version = value.String
			}
		case node.FieldFileName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_name", values[i])
			} else if value.Valid {
				n.FileName = value.String
			}
		case node.FieldURLHome:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field url_home", values[i])
			} else if value.Valid {
				n.URLHome = value.String
			}
		case node.FieldURLDownload:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field url_download", values[i])
			} else if value.Valid {
				n.URLDownload = value.String
			}
		case node.FieldLicenses:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field licenses", values[i])
			} else if value.Valid {
				n.Licenses = value.String
			}
		case node.FieldLicenseConcluded:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field license_concluded", values[i])
			} else if value.Valid {
				n.LicenseConcluded = value.String
			}
		case node.FieldLicenseComments:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field license_comments", values[i])
			} else if value.Valid {
				n.LicenseComments = value.String
			}
		case node.FieldCopyright:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field copyright", values[i])
			} else if value.Valid {
				n.Copyright = value.String
			}
		case node.FieldSourceInfo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source_info", values[i])
			} else if value.Valid {
				n.SourceInfo = value.String
			}
		case node.FieldComment:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field comment", values[i])
			} else if value.Valid {
				n.Comment = value.String
			}
		case node.FieldSummary:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field summary", values[i])
			} else if value.Valid {
				n.Summary = value.String
			}
		case node.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				n.Description = value.String
			}
		case node.FieldAttribution:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field attribution", values[i])
			} else if value.Valid {
				n.Attribution = value.String
			}
		case node.FieldFileTypes:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_types", values[i])
			} else if value.Valid {
				n.FileTypes = value.String
			}
		case node.FieldPrimaryPurpose:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field primary_purpose", values[i])
			} else if value.Valid {
				n.PrimaryPurpose = node.PrimaryPurpose(value.String)
			}
		case node.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field node_list_nodes", value)
			} else if value.Valid {
				n.node_list_nodes = new(int)
				*n.node_list_nodes = int(value.Int64)
			}
		default:
			n.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Node.
// This includes values selected through modifiers, order, etc.
func (n *Node) Value(name string) (ent.Value, error) {
	return n.selectValues.Get(name)
}

// QuerySuppliers queries the "suppliers" edge of the Node entity.
func (n *Node) QuerySuppliers() *PersonQuery {
	return NewNodeClient(n.config).QuerySuppliers(n)
}

// QueryOriginators queries the "originators" edge of the Node entity.
func (n *Node) QueryOriginators() *PersonQuery {
	return NewNodeClient(n.config).QueryOriginators(n)
}

// QueryExternalReferences queries the "external_references" edge of the Node entity.
func (n *Node) QueryExternalReferences() *ExternalReferenceQuery {
	return NewNodeClient(n.config).QueryExternalReferences(n)
}

// QueryIdentifiers queries the "identifiers" edge of the Node entity.
func (n *Node) QueryIdentifiers() *IdentifiersEntryQuery {
	return NewNodeClient(n.config).QueryIdentifiers(n)
}

// QueryHashes queries the "hashes" edge of the Node entity.
func (n *Node) QueryHashes() *HashesEntryQuery {
	return NewNodeClient(n.config).QueryHashes(n)
}

// QueryReleaseDate queries the "release_date" edge of the Node entity.
func (n *Node) QueryReleaseDate() *TimestampQuery {
	return NewNodeClient(n.config).QueryReleaseDate(n)
}

// QueryBuildDate queries the "build_date" edge of the Node entity.
func (n *Node) QueryBuildDate() *TimestampQuery {
	return NewNodeClient(n.config).QueryBuildDate(n)
}

// QueryValidUntilDate queries the "valid_until_date" edge of the Node entity.
func (n *Node) QueryValidUntilDate() *TimestampQuery {
	return NewNodeClient(n.config).QueryValidUntilDate(n)
}

// Update returns a builder for updating this Node.
// Note that you need to call Node.Unwrap() before calling this method if this Node
// was returned from a transaction, and the transaction was committed or rolled back.
func (n *Node) Update() *NodeUpdateOne {
	return NewNodeClient(n.config).UpdateOne(n)
}

// Unwrap unwraps the Node entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (n *Node) Unwrap() *Node {
	_tx, ok := n.config.driver.(*txDriver)
	if !ok {
		panic("ent: Node is not a transactional entity")
	}
	n.config.driver = _tx.drv
	return n
}

// String implements the fmt.Stringer.
func (n *Node) String() string {
	var builder strings.Builder
	builder.WriteString("Node(")
	builder.WriteString(fmt.Sprintf("id=%v, ", n.ID))
	builder.WriteString("type=")
	builder.WriteString(fmt.Sprintf("%v", n.Type))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(n.Name)
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(n.Version)
	builder.WriteString(", ")
	builder.WriteString("file_name=")
	builder.WriteString(n.FileName)
	builder.WriteString(", ")
	builder.WriteString("url_home=")
	builder.WriteString(n.URLHome)
	builder.WriteString(", ")
	builder.WriteString("url_download=")
	builder.WriteString(n.URLDownload)
	builder.WriteString(", ")
	builder.WriteString("licenses=")
	builder.WriteString(n.Licenses)
	builder.WriteString(", ")
	builder.WriteString("license_concluded=")
	builder.WriteString(n.LicenseConcluded)
	builder.WriteString(", ")
	builder.WriteString("license_comments=")
	builder.WriteString(n.LicenseComments)
	builder.WriteString(", ")
	builder.WriteString("copyright=")
	builder.WriteString(n.Copyright)
	builder.WriteString(", ")
	builder.WriteString("source_info=")
	builder.WriteString(n.SourceInfo)
	builder.WriteString(", ")
	builder.WriteString("comment=")
	builder.WriteString(n.Comment)
	builder.WriteString(", ")
	builder.WriteString("summary=")
	builder.WriteString(n.Summary)
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(n.Description)
	builder.WriteString(", ")
	builder.WriteString("attribution=")
	builder.WriteString(n.Attribution)
	builder.WriteString(", ")
	builder.WriteString("file_types=")
	builder.WriteString(n.FileTypes)
	builder.WriteString(", ")
	builder.WriteString("primary_purpose=")
	builder.WriteString(fmt.Sprintf("%v", n.PrimaryPurpose))
	builder.WriteByte(')')
	return builder.String()
}

// Nodes is a parsable slice of Node.
type Nodes []*Node
