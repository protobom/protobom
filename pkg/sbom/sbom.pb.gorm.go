package sbom

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type DocumentORM struct {
	Id       string       `gorm:"primaryKey"`
	Metadata *MetadataORM `gorm:"foreignKey:DocumentId;references:Id"`
	NodeList *NodeListORM `gorm:"foreignKey:DocumentId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (DocumentORM) TableName() string {
	return "documents"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Document) ToORM(ctx context.Context) (DocumentORM, error) {
	to := DocumentORM{}
	var err error
	if prehook, ok := interface{}(m).(DocumentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Metadata != nil {
		tempMetadata, err := m.Metadata.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Metadata = &tempMetadata
	}
	if m.NodeList != nil {
		tempNodeList, err := m.NodeList.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NodeList = &tempNodeList
	}
	if posthook, ok := interface{}(m).(DocumentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DocumentORM) ToPB(ctx context.Context) (Document, error) {
	to := Document{}
	var err error
	if prehook, ok := interface{}(m).(DocumentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Metadata != nil {
		tempMetadata, err := m.Metadata.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Metadata = &tempMetadata
	}
	if m.NodeList != nil {
		tempNodeList, err := m.NodeList.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NodeList = &tempNodeList
	}
	if posthook, ok := interface{}(m).(DocumentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Document the arg will be the target, the caller the one being converted from

// DocumentBeforeToORM called before default ToORM code
type DocumentWithBeforeToORM interface {
	BeforeToORM(context.Context, *DocumentORM) error
}

// DocumentAfterToORM called after default ToORM code
type DocumentWithAfterToORM interface {
	AfterToORM(context.Context, *DocumentORM) error
}

// DocumentBeforeToPB called before default ToPB code
type DocumentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Document) error
}

// DocumentAfterToPB called after default ToPB code
type DocumentWithAfterToPB interface {
	AfterToPB(context.Context, *Document) error
}

type NodeORM struct {
	BuildDate          *time.Time
	Comment            string
	Copyright          string
	Description        string
	ExternalReferences []*ExternalReferenceORM `gorm:"foreignKey:NodeId;references:Id"`
	FileName           string
	Id                 string `gorm:"primaryKey"`
	LicenseComments    string
	LicenseConcluded   string
	Name               string
	NodeListId         *string
	Originators        []*PersonORM `gorm:"foreignKey:OriginatorsNodeId;references:Id"`
	ReleaseDate        *time.Time
	SourceInfo         string
	Summary            string
	Suppliers          []*PersonORM `gorm:"foreignKey:SuppliersNodeId;references:Id"`
	Type               int32
	UrlDownload        string
	UrlHome            string
	ValidUntilDate     *time.Time
	Version            string
}

// TableName overrides the default tablename generated by GORM
func (NodeORM) TableName() string {
	return "nodes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Node) ToORM(ctx context.Context) (NodeORM, error) {
	to := NodeORM{}
	var err error
	if prehook, ok := interface{}(m).(NodeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = int32(m.Type)
	to.Name = m.Name
	to.Version = m.Version
	to.FileName = m.FileName
	to.UrlHome = m.UrlHome
	to.UrlDownload = m.UrlDownload
	// Repeated type string is not an ORMable message type
	to.LicenseConcluded = m.LicenseConcluded
	to.LicenseComments = m.LicenseComments
	to.Copyright = m.Copyright
	to.SourceInfo = m.SourceInfo
	to.Comment = m.Comment
	to.Summary = m.Summary
	to.Description = m.Description
	// Repeated type string is not an ORMable message type
	for _, v := range m.Suppliers {
		if v != nil {
			if tempSuppliers, cErr := v.ToORM(ctx); cErr == nil {
				to.Suppliers = append(to.Suppliers, &tempSuppliers)
			} else {
				return to, cErr
			}
		} else {
			to.Suppliers = append(to.Suppliers, nil)
		}
	}
	for _, v := range m.Originators {
		if v != nil {
			if tempOriginators, cErr := v.ToORM(ctx); cErr == nil {
				to.Originators = append(to.Originators, &tempOriginators)
			} else {
				return to, cErr
			}
		} else {
			to.Originators = append(to.Originators, nil)
		}
	}
	if m.ReleaseDate != nil {
		t := m.ReleaseDate.AsTime()
		to.ReleaseDate = &t
	}
	if m.BuildDate != nil {
		t := m.BuildDate.AsTime()
		to.BuildDate = &t
	}
	if m.ValidUntilDate != nil {
		t := m.ValidUntilDate.AsTime()
		to.ValidUntilDate = &t
	}
	for _, v := range m.ExternalReferences {
		if v != nil {
			if tempExternalReferences, cErr := v.ToORM(ctx); cErr == nil {
				to.ExternalReferences = append(to.ExternalReferences, &tempExternalReferences)
			} else {
				return to, cErr
			}
		} else {
			to.ExternalReferences = append(to.ExternalReferences, nil)
		}
	}
	// Repeated type string is not an ORMable message type
	// Repeated type IdentifiersEntry is not an ORMable message type
	// Repeated type HashesEntry is not an ORMable message type
	// Repeated type enum is not an ORMable message type
	if posthook, ok := interface{}(m).(NodeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NodeORM) ToPB(ctx context.Context) (Node, error) {
	to := Node{}
	var err error
	if prehook, ok := interface{}(m).(NodeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = Node_NodeType(m.Type)
	to.Name = m.Name
	to.Version = m.Version
	to.FileName = m.FileName
	to.UrlHome = m.UrlHome
	to.UrlDownload = m.UrlDownload
	// Repeated type string is not an ORMable message type
	to.LicenseConcluded = m.LicenseConcluded
	to.LicenseComments = m.LicenseComments
	to.Copyright = m.Copyright
	to.SourceInfo = m.SourceInfo
	to.Comment = m.Comment
	to.Summary = m.Summary
	to.Description = m.Description
	// Repeated type string is not an ORMable message type
	for _, v := range m.Suppliers {
		if v != nil {
			if tempSuppliers, cErr := v.ToPB(ctx); cErr == nil {
				to.Suppliers = append(to.Suppliers, &tempSuppliers)
			} else {
				return to, cErr
			}
		} else {
			to.Suppliers = append(to.Suppliers, nil)
		}
	}
	for _, v := range m.Originators {
		if v != nil {
			if tempOriginators, cErr := v.ToPB(ctx); cErr == nil {
				to.Originators = append(to.Originators, &tempOriginators)
			} else {
				return to, cErr
			}
		} else {
			to.Originators = append(to.Originators, nil)
		}
	}
	if m.ReleaseDate != nil {
		to.ReleaseDate = timestamppb.New(*m.ReleaseDate)
	}
	if m.BuildDate != nil {
		to.BuildDate = timestamppb.New(*m.BuildDate)
	}
	if m.ValidUntilDate != nil {
		to.ValidUntilDate = timestamppb.New(*m.ValidUntilDate)
	}
	for _, v := range m.ExternalReferences {
		if v != nil {
			if tempExternalReferences, cErr := v.ToPB(ctx); cErr == nil {
				to.ExternalReferences = append(to.ExternalReferences, &tempExternalReferences)
			} else {
				return to, cErr
			}
		} else {
			to.ExternalReferences = append(to.ExternalReferences, nil)
		}
	}
	// Repeated type string is not an ORMable message type
	// Repeated type IdentifiersEntry is not an ORMable message type
	// Repeated type HashesEntry is not an ORMable message type
	// Repeated type enum is not an ORMable message type
	if posthook, ok := interface{}(m).(NodeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Node the arg will be the target, the caller the one being converted from

// NodeBeforeToORM called before default ToORM code
type NodeWithBeforeToORM interface {
	BeforeToORM(context.Context, *NodeORM) error
}

// NodeAfterToORM called after default ToORM code
type NodeWithAfterToORM interface {
	AfterToORM(context.Context, *NodeORM) error
}

// NodeBeforeToPB called before default ToPB code
type NodeWithBeforeToPB interface {
	BeforeToPB(context.Context, *Node) error
}

// NodeAfterToPB called after default ToPB code
type NodeWithAfterToPB interface {
	AfterToPB(context.Context, *Node) error
}

type MetadataORM struct {
	Authors       []*PersonORM `gorm:"foreignKey:MetadataId;references:Id"`
	Comment       string
	Date          time.Time
	DocumentId    *string
	DocumentTypes []*DocumentTypeORM `gorm:"foreignKey:MetadataId;references:Id"`
	Id            string             `gorm:"primaryKey"`
	Name          string
	Tools         []*ToolORM `gorm:"foreignKey:MetadataId;references:Id"`
	Version       string
}

// TableName overrides the default tablename generated by GORM
func (MetadataORM) TableName() string {
	return "metadata"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Metadata) ToORM(ctx context.Context) (MetadataORM, error) {
	to := MetadataORM{}
	var err error
	if prehook, ok := interface{}(m).(MetadataWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Version = m.Version
	to.Name = m.Name
	for _, v := range m.Tools {
		if v != nil {
			if tempTools, cErr := v.ToORM(ctx); cErr == nil {
				to.Tools = append(to.Tools, &tempTools)
			} else {
				return to, cErr
			}
		} else {
			to.Tools = append(to.Tools, nil)
		}
	}
	for _, v := range m.Authors {
		if v != nil {
			if tempAuthors, cErr := v.ToORM(ctx); cErr == nil {
				to.Authors = append(to.Authors, &tempAuthors)
			} else {
				return to, cErr
			}
		} else {
			to.Authors = append(to.Authors, nil)
		}
	}
	to.Comment = m.Comment
	for _, v := range m.DocumentTypes {
		if v != nil {
			if tempDocumentTypes, cErr := v.ToORM(ctx); cErr == nil {
				to.DocumentTypes = append(to.DocumentTypes, &tempDocumentTypes)
			} else {
				return to, cErr
			}
		} else {
			to.DocumentTypes = append(to.DocumentTypes, nil)
		}
	}
	if posthook, ok := interface{}(m).(MetadataWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MetadataORM) ToPB(ctx context.Context) (Metadata, error) {
	to := Metadata{}
	var err error
	if prehook, ok := interface{}(m).(MetadataWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Version = m.Version
	to.Name = m.Name
	for _, v := range m.Tools {
		if v != nil {
			if tempTools, cErr := v.ToPB(ctx); cErr == nil {
				to.Tools = append(to.Tools, &tempTools)
			} else {
				return to, cErr
			}
		} else {
			to.Tools = append(to.Tools, nil)
		}
	}
	for _, v := range m.Authors {
		if v != nil {
			if tempAuthors, cErr := v.ToPB(ctx); cErr == nil {
				to.Authors = append(to.Authors, &tempAuthors)
			} else {
				return to, cErr
			}
		} else {
			to.Authors = append(to.Authors, nil)
		}
	}
	to.Comment = m.Comment
	for _, v := range m.DocumentTypes {
		if v != nil {
			if tempDocumentTypes, cErr := v.ToPB(ctx); cErr == nil {
				to.DocumentTypes = append(to.DocumentTypes, &tempDocumentTypes)
			} else {
				return to, cErr
			}
		} else {
			to.DocumentTypes = append(to.DocumentTypes, nil)
		}
	}
	if posthook, ok := interface{}(m).(MetadataWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Metadata the arg will be the target, the caller the one being converted from

// MetadataBeforeToORM called before default ToORM code
type MetadataWithBeforeToORM interface {
	BeforeToORM(context.Context, *MetadataORM) error
}

// MetadataAfterToORM called after default ToORM code
type MetadataWithAfterToORM interface {
	AfterToORM(context.Context, *MetadataORM) error
}

// MetadataBeforeToPB called before default ToPB code
type MetadataWithBeforeToPB interface {
	BeforeToPB(context.Context, *Metadata) error
}

// MetadataAfterToPB called after default ToPB code
type MetadataWithAfterToPB interface {
	AfterToPB(context.Context, *Metadata) error
}

type EdgeORM struct {
	From       string
	NodeListId *string
	Type       int32
}

// TableName overrides the default tablename generated by GORM
func (EdgeORM) TableName() string {
	return "edges"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Edge) ToORM(ctx context.Context) (EdgeORM, error) {
	to := EdgeORM{}
	var err error
	if prehook, ok := interface{}(m).(EdgeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Type = int32(m.Type)
	to.From = m.From
	// Repeated type string is not an ORMable message type
	if posthook, ok := interface{}(m).(EdgeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EdgeORM) ToPB(ctx context.Context) (Edge, error) {
	to := Edge{}
	var err error
	if prehook, ok := interface{}(m).(EdgeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Type = Edge_Type(m.Type)
	to.From = m.From
	// Repeated type string is not an ORMable message type
	if posthook, ok := interface{}(m).(EdgeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Edge the arg will be the target, the caller the one being converted from

// EdgeBeforeToORM called before default ToORM code
type EdgeWithBeforeToORM interface {
	BeforeToORM(context.Context, *EdgeORM) error
}

// EdgeAfterToORM called after default ToORM code
type EdgeWithAfterToORM interface {
	AfterToORM(context.Context, *EdgeORM) error
}

// EdgeBeforeToPB called before default ToPB code
type EdgeWithBeforeToPB interface {
	BeforeToPB(context.Context, *Edge) error
}

// EdgeAfterToPB called after default ToPB code
type EdgeWithAfterToPB interface {
	AfterToPB(context.Context, *Edge) error
}

type ExternalReferenceORM struct {
	Authority string `gorm:"primaryKey"`
	Comment   string `gorm:"primaryKey"`
	NodeId    *string
	Type      int32
	Url       string `gorm:"primaryKey"`
}

// TableName overrides the default tablename generated by GORM
func (ExternalReferenceORM) TableName() string {
	return "external_references"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ExternalReference) ToORM(ctx context.Context) (ExternalReferenceORM, error) {
	to := ExternalReferenceORM{}
	var err error
	if prehook, ok := interface{}(m).(ExternalReferenceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Url = m.Url
	to.Comment = m.Comment
	to.Authority = m.Authority
	// Repeated type HashesEntry is not an ORMable message type
	to.Type = int32(m.Type)
	if posthook, ok := interface{}(m).(ExternalReferenceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExternalReferenceORM) ToPB(ctx context.Context) (ExternalReference, error) {
	to := ExternalReference{}
	var err error
	if prehook, ok := interface{}(m).(ExternalReferenceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Url = m.Url
	to.Comment = m.Comment
	to.Authority = m.Authority
	// Repeated type HashesEntry is not an ORMable message type
	to.Type = ExternalReference_ExternalReferenceType(m.Type)
	if posthook, ok := interface{}(m).(ExternalReferenceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ExternalReference the arg will be the target, the caller the one being converted from

// ExternalReferenceBeforeToORM called before default ToORM code
type ExternalReferenceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExternalReferenceORM) error
}

// ExternalReferenceAfterToORM called after default ToORM code
type ExternalReferenceWithAfterToORM interface {
	AfterToORM(context.Context, *ExternalReferenceORM) error
}

// ExternalReferenceBeforeToPB called before default ToPB code
type ExternalReferenceWithBeforeToPB interface {
	BeforeToPB(context.Context, *ExternalReference) error
}

// ExternalReferenceAfterToPB called after default ToPB code
type ExternalReferenceWithAfterToPB interface {
	AfterToPB(context.Context, *ExternalReference) error
}

type PersonORM struct {
	Contacts          []*PersonORM `gorm:"foreignKey:Id;references:Id;many2many:person_contacts;joinForeignKey:PersonId;joinReferences:ContactId"`
	Email             string
	Id                int32 `gorm:"primaryKey"`
	IsOrg             bool
	MetadataId        *string
	Name              string
	OriginatorsNodeId *string
	Phone             string
	SuppliersNodeId   *string
	Url               string
}

// TableName overrides the default tablename generated by GORM
func (PersonORM) TableName() string {
	return "people"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Person) ToORM(ctx context.Context) (PersonORM, error) {
	to := PersonORM{}
	var err error
	if prehook, ok := interface{}(m).(PersonWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.IsOrg = m.IsOrg
	to.Email = m.Email
	to.Url = m.Url
	to.Phone = m.Phone
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(PersonWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PersonORM) ToPB(ctx context.Context) (Person, error) {
	to := Person{}
	var err error
	if prehook, ok := interface{}(m).(PersonWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.IsOrg = m.IsOrg
	to.Email = m.Email
	to.Url = m.Url
	to.Phone = m.Phone
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(PersonWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Person the arg will be the target, the caller the one being converted from

// PersonBeforeToORM called before default ToORM code
type PersonWithBeforeToORM interface {
	BeforeToORM(context.Context, *PersonORM) error
}

// PersonAfterToORM called after default ToORM code
type PersonWithAfterToORM interface {
	AfterToORM(context.Context, *PersonORM) error
}

// PersonBeforeToPB called before default ToPB code
type PersonWithBeforeToPB interface {
	BeforeToPB(context.Context, *Person) error
}

// PersonAfterToPB called after default ToPB code
type PersonWithAfterToPB interface {
	AfterToPB(context.Context, *Person) error
}

type ToolORM struct {
	MetadataId *string
	Name       string `gorm:"primaryKey"`
	Vendor     string `gorm:"primaryKey"`
	Version    string `gorm:"primaryKey"`
}

// TableName overrides the default tablename generated by GORM
func (ToolORM) TableName() string {
	return "tools"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tool) ToORM(ctx context.Context) (ToolORM, error) {
	to := ToolORM{}
	var err error
	if prehook, ok := interface{}(m).(ToolWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Version = m.Version
	to.Vendor = m.Vendor
	if posthook, ok := interface{}(m).(ToolWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ToolORM) ToPB(ctx context.Context) (Tool, error) {
	to := Tool{}
	var err error
	if prehook, ok := interface{}(m).(ToolWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Version = m.Version
	to.Vendor = m.Vendor
	if posthook, ok := interface{}(m).(ToolWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tool the arg will be the target, the caller the one being converted from

// ToolBeforeToORM called before default ToORM code
type ToolWithBeforeToORM interface {
	BeforeToORM(context.Context, *ToolORM) error
}

// ToolAfterToORM called after default ToORM code
type ToolWithAfterToORM interface {
	AfterToORM(context.Context, *ToolORM) error
}

// ToolBeforeToPB called before default ToPB code
type ToolWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tool) error
}

// ToolAfterToPB called after default ToPB code
type ToolWithAfterToPB interface {
	AfterToPB(context.Context, *Tool) error
}

type DocumentTypeORM struct {
	Description *string `gorm:"uniqueIndex:idx_document_type"`
	MetadataId  *string
	Name        *string `gorm:"uniqueIndex:idx_document_type"`
	Type        int32   `gorm:"uniqueIndex:idx_document_type"`
}

// TableName overrides the default tablename generated by GORM
func (DocumentTypeORM) TableName() string {
	return "document_types"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DocumentType) ToORM(ctx context.Context) (DocumentTypeORM, error) {
	to := DocumentTypeORM{}
	var err error
	if prehook, ok := interface{}(m).(DocumentTypeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(DocumentTypeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DocumentTypeORM) ToPB(ctx context.Context) (DocumentType, error) {
	to := DocumentType{}
	var err error
	if prehook, ok := interface{}(m).(DocumentTypeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(DocumentTypeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DocumentType the arg will be the target, the caller the one being converted from

// DocumentTypeBeforeToORM called before default ToORM code
type DocumentTypeWithBeforeToORM interface {
	BeforeToORM(context.Context, *DocumentTypeORM) error
}

// DocumentTypeAfterToORM called after default ToORM code
type DocumentTypeWithAfterToORM interface {
	AfterToORM(context.Context, *DocumentTypeORM) error
}

// DocumentTypeBeforeToPB called before default ToPB code
type DocumentTypeWithBeforeToPB interface {
	BeforeToPB(context.Context, *DocumentType) error
}

// DocumentTypeAfterToPB called after default ToPB code
type DocumentTypeWithAfterToPB interface {
	AfterToPB(context.Context, *DocumentType) error
}

type NodeListORM struct {
	DocumentId *string
	Edges      []*EdgeORM `gorm:"foreignKey:NodeListId;references:Id"`
	Id         string     `gorm:"type:text;primaryKey"`
	Nodes      []*NodeORM `gorm:"foreignKey:NodeListId;references:Id"`
}

// TableName overrides the default tablename generated by GORM
func (NodeListORM) TableName() string {
	return "node_lists"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NodeList) ToORM(ctx context.Context) (NodeListORM, error) {
	to := NodeListORM{}
	var err error
	if prehook, ok := interface{}(m).(NodeListWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	for _, v := range m.Nodes {
		if v != nil {
			if tempNodes, cErr := v.ToORM(ctx); cErr == nil {
				to.Nodes = append(to.Nodes, &tempNodes)
			} else {
				return to, cErr
			}
		} else {
			to.Nodes = append(to.Nodes, nil)
		}
	}
	for _, v := range m.Edges {
		if v != nil {
			if tempEdges, cErr := v.ToORM(ctx); cErr == nil {
				to.Edges = append(to.Edges, &tempEdges)
			} else {
				return to, cErr
			}
		} else {
			to.Edges = append(to.Edges, nil)
		}
	}
	// Repeated type string is not an ORMable message type
	to.Id = m.Id
	if posthook, ok := interface{}(m).(NodeListWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NodeListORM) ToPB(ctx context.Context) (NodeList, error) {
	to := NodeList{}
	var err error
	if prehook, ok := interface{}(m).(NodeListWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	for _, v := range m.Nodes {
		if v != nil {
			if tempNodes, cErr := v.ToPB(ctx); cErr == nil {
				to.Nodes = append(to.Nodes, &tempNodes)
			} else {
				return to, cErr
			}
		} else {
			to.Nodes = append(to.Nodes, nil)
		}
	}
	for _, v := range m.Edges {
		if v != nil {
			if tempEdges, cErr := v.ToPB(ctx); cErr == nil {
				to.Edges = append(to.Edges, &tempEdges)
			} else {
				return to, cErr
			}
		} else {
			to.Edges = append(to.Edges, nil)
		}
	}
	// Repeated type string is not an ORMable message type
	to.Id = m.Id
	if posthook, ok := interface{}(m).(NodeListWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NodeList the arg will be the target, the caller the one being converted from

// NodeListBeforeToORM called before default ToORM code
type NodeListWithBeforeToORM interface {
	BeforeToORM(context.Context, *NodeListORM) error
}

// NodeListAfterToORM called after default ToORM code
type NodeListWithAfterToORM interface {
	AfterToORM(context.Context, *NodeListORM) error
}

// NodeListBeforeToPB called before default ToPB code
type NodeListWithBeforeToPB interface {
	BeforeToPB(context.Context, *NodeList) error
}

// NodeListAfterToPB called after default ToPB code
type NodeListWithAfterToPB interface {
	AfterToPB(context.Context, *NodeList) error
}

// DefaultCreateDocument executes a basic gorm create call
func DefaultCreateDocument(ctx context.Context, in *Document, db *gorm.DB) (*Document, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DocumentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDocument(ctx context.Context, in *Document, db *gorm.DB) (*Document, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DocumentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DocumentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DocumentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDocument(ctx context.Context, in *Document, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DocumentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DocumentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDocumentSet(ctx context.Context, in []*Document, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DocumentORM{})).(DocumentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DocumentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DocumentORM{})).(DocumentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DocumentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Document, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Document, *gorm.DB) error
}

// DefaultStrictUpdateDocument clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDocument(ctx context.Context, in *Document, db *gorm.DB) (*Document, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDocument")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DocumentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterMetadata := MetadataORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterMetadata.DocumentId = new(string)
	*filterMetadata.DocumentId = ormObj.Id
	if err = db.Where(filterMetadata).Delete(MetadataORM{}).Error; err != nil {
		return nil, err
	}
	filterNodeList := NodeListORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterNodeList.DocumentId = new(string)
	*filterNodeList.DocumentId = ormObj.Id
	if err = db.Where(filterNodeList).Delete(NodeListORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DocumentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDocument executes a basic gorm update call with patch behavior
func DefaultPatchDocument(ctx context.Context, in *Document, updateMask *field_mask.FieldMask, db *gorm.DB) (*Document, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Document
	var err error
	if hook, ok := interface{}(&pbObj).(DocumentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(DocumentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDocument(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DocumentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDocument(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DocumentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DocumentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Document, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Document, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Document, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DocumentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Document, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDocument executes a bulk gorm update call with patch behavior
func DefaultPatchSetDocument(ctx context.Context, objects []*Document, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Document, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Document, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDocument(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDocument patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDocument(ctx context.Context, patchee *Document, patcher *Document, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Document, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedMetadata bool
	var updatedNodeList bool
	for i, f := range updateMask.Paths {
		if !updatedMetadata && strings.HasPrefix(f, prefix+"Metadata.") {
			updatedMetadata = true
			if patcher.Metadata == nil {
				patchee.Metadata = nil
				continue
			}
			if patchee.Metadata == nil {
				patchee.Metadata = &Metadata{}
			}
			if o, err := DefaultApplyFieldMaskMetadata(ctx, patchee.Metadata, patcher.Metadata, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Metadata.", db); err != nil {
				return nil, err
			} else {
				patchee.Metadata = o
			}
			continue
		}
		if f == prefix+"Metadata" {
			updatedMetadata = true
			patchee.Metadata = patcher.Metadata
			continue
		}
		if !updatedNodeList && strings.HasPrefix(f, prefix+"NodeList.") {
			updatedNodeList = true
			if patcher.NodeList == nil {
				patchee.NodeList = nil
				continue
			}
			if patchee.NodeList == nil {
				patchee.NodeList = &NodeList{}
			}
			if o, err := DefaultApplyFieldMaskNodeList(ctx, patchee.NodeList, patcher.NodeList, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NodeList.", db); err != nil {
				return nil, err
			} else {
				patchee.NodeList = o
			}
			continue
		}
		if f == prefix+"NodeList" {
			updatedNodeList = true
			patchee.NodeList = patcher.NodeList
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDocument executes a gorm list call
func DefaultListDocument(ctx context.Context, db *gorm.DB) ([]*Document, error) {
	in := Document{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DocumentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Document{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DocumentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DocumentORM) error
}

// DefaultCreateNode executes a basic gorm create call
func DefaultCreateNode(ctx context.Context, in *Node, db *gorm.DB) (*Node, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NodeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNode(ctx context.Context, in *Node, db *gorm.DB) (*Node, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NodeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NodeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NodeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNode(ctx context.Context, in *Node, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NodeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NodeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNodeSet(ctx context.Context, in []*Node, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NodeORM{})).(NodeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NodeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NodeORM{})).(NodeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NodeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Node, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Node, *gorm.DB) error
}

// DefaultStrictUpdateNode clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNode(ctx context.Context, in *Node, db *gorm.DB) (*Node, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNode")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NodeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterExternalReferences := ExternalReferenceORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterExternalReferences.NodeId = new(string)
	*filterExternalReferences.NodeId = ormObj.Id
	if err = db.Where(filterExternalReferences).Delete(ExternalReferenceORM{}).Error; err != nil {
		return nil, err
	}
	filterOriginators := PersonORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterOriginators.OriginatorsNodeId = new(string)
	*filterOriginators.OriginatorsNodeId = ormObj.Id
	if err = db.Where(filterOriginators).Delete(PersonORM{}).Error; err != nil {
		return nil, err
	}
	filterSuppliers := PersonORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterSuppliers.SuppliersNodeId = new(string)
	*filterSuppliers.SuppliersNodeId = ormObj.Id
	if err = db.Where(filterSuppliers).Delete(PersonORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NodeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNode executes a basic gorm update call with patch behavior
func DefaultPatchNode(ctx context.Context, in *Node, updateMask *field_mask.FieldMask, db *gorm.DB) (*Node, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Node
	var err error
	if hook, ok := interface{}(&pbObj).(NodeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNode(ctx, &Node{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NodeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNode(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NodeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNode(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NodeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NodeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Node, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NodeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Node, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NodeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Node, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NodeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Node, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNode executes a bulk gorm update call with patch behavior
func DefaultPatchSetNode(ctx context.Context, objects []*Node, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Node, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Node, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNode(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNode patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNode(ctx context.Context, patchee *Node, patcher *Node, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Node, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedReleaseDate bool
	var updatedBuildDate bool
	var updatedValidUntilDate bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"UrlHome" {
			patchee.UrlHome = patcher.UrlHome
			continue
		}
		if f == prefix+"UrlDownload" {
			patchee.UrlDownload = patcher.UrlDownload
			continue
		}
		if f == prefix+"Licenses" {
			patchee.Licenses = patcher.Licenses
			continue
		}
		if f == prefix+"LicenseConcluded" {
			patchee.LicenseConcluded = patcher.LicenseConcluded
			continue
		}
		if f == prefix+"LicenseComments" {
			patchee.LicenseComments = patcher.LicenseComments
			continue
		}
		if f == prefix+"Copyright" {
			patchee.Copyright = patcher.Copyright
			continue
		}
		if f == prefix+"SourceInfo" {
			patchee.SourceInfo = patcher.SourceInfo
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Summary" {
			patchee.Summary = patcher.Summary
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Attribution" {
			patchee.Attribution = patcher.Attribution
			continue
		}
		if f == prefix+"Suppliers" {
			patchee.Suppliers = patcher.Suppliers
			continue
		}
		if f == prefix+"Originators" {
			patchee.Originators = patcher.Originators
			continue
		}
		if !updatedReleaseDate && strings.HasPrefix(f, prefix+"ReleaseDate.") {
			if patcher.ReleaseDate == nil {
				patchee.ReleaseDate = nil
				continue
			}
			if patchee.ReleaseDate == nil {
				patchee.ReleaseDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ReleaseDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ReleaseDate, patchee.ReleaseDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ReleaseDate" {
			updatedReleaseDate = true
			patchee.ReleaseDate = patcher.ReleaseDate
			continue
		}
		if !updatedBuildDate && strings.HasPrefix(f, prefix+"BuildDate.") {
			if patcher.BuildDate == nil {
				patchee.BuildDate = nil
				continue
			}
			if patchee.BuildDate == nil {
				patchee.BuildDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"BuildDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.BuildDate, patchee.BuildDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"BuildDate" {
			updatedBuildDate = true
			patchee.BuildDate = patcher.BuildDate
			continue
		}
		if !updatedValidUntilDate && strings.HasPrefix(f, prefix+"ValidUntilDate.") {
			if patcher.ValidUntilDate == nil {
				patchee.ValidUntilDate = nil
				continue
			}
			if patchee.ValidUntilDate == nil {
				patchee.ValidUntilDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ValidUntilDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ValidUntilDate, patchee.ValidUntilDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ValidUntilDate" {
			updatedValidUntilDate = true
			patchee.ValidUntilDate = patcher.ValidUntilDate
			continue
		}
		if f == prefix+"ExternalReferences" {
			patchee.ExternalReferences = patcher.ExternalReferences
			continue
		}
		if f == prefix+"FileTypes" {
			patchee.FileTypes = patcher.FileTypes
			continue
		}
		if f == prefix+"Identifiers" {
			patchee.Identifiers = patcher.Identifiers
			continue
		}
		if f == prefix+"Hashes" {
			patchee.Hashes = patcher.Hashes
			continue
		}
		if f == prefix+"PrimaryPurpose" {
			patchee.PrimaryPurpose = patcher.PrimaryPurpose
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNode executes a gorm list call
func DefaultListNode(ctx context.Context, db *gorm.DB) ([]*Node, error) {
	in := Node{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NodeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Node{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NodeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NodeORM) error
}

// DefaultCreateMetadata executes a basic gorm create call
func DefaultCreateMetadata(ctx context.Context, in *Metadata, db *gorm.DB) (*Metadata, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MetadataORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMetadata(ctx context.Context, in *Metadata, db *gorm.DB) (*Metadata, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MetadataORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MetadataORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MetadataORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMetadata(ctx context.Context, in *Metadata, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MetadataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MetadataORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMetadataSet(ctx context.Context, in []*Metadata, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MetadataORM{})).(MetadataORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MetadataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MetadataORM{})).(MetadataORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MetadataORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Metadata, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Metadata, *gorm.DB) error
}

// DefaultStrictUpdateMetadata clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMetadata(ctx context.Context, in *Metadata, db *gorm.DB) (*Metadata, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMetadata")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MetadataORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAuthors := PersonORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterAuthors.MetadataId = new(string)
	*filterAuthors.MetadataId = ormObj.Id
	if err = db.Where(filterAuthors).Delete(PersonORM{}).Error; err != nil {
		return nil, err
	}
	filterDocumentTypes := DocumentTypeORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterDocumentTypes.MetadataId = new(string)
	*filterDocumentTypes.MetadataId = ormObj.Id
	if err = db.Where(filterDocumentTypes).Delete(DocumentTypeORM{}).Error; err != nil {
		return nil, err
	}
	filterTools := ToolORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterTools.MetadataId = new(string)
	*filterTools.MetadataId = ormObj.Id
	if err = db.Where(filterTools).Delete(ToolORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MetadataORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMetadata executes a basic gorm update call with patch behavior
func DefaultPatchMetadata(ctx context.Context, in *Metadata, updateMask *field_mask.FieldMask, db *gorm.DB) (*Metadata, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Metadata
	var err error
	if hook, ok := interface{}(&pbObj).(MetadataWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMetadata(ctx, &Metadata{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MetadataWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMetadata(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MetadataWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMetadata(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MetadataWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MetadataWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Metadata, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MetadataWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Metadata, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MetadataWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Metadata, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MetadataWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Metadata, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMetadata executes a bulk gorm update call with patch behavior
func DefaultPatchSetMetadata(ctx context.Context, objects []*Metadata, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Metadata, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Metadata, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMetadata(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMetadata patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMetadata(ctx context.Context, patchee *Metadata, patcher *Metadata, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Metadata, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDate bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedDate && strings.HasPrefix(f, prefix+"Date.") {
			if patcher.Date == nil {
				patchee.Date = nil
				continue
			}
			if patchee.Date == nil {
				patchee.Date = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Date."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Date, patchee.Date, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Date" {
			updatedDate = true
			patchee.Date = patcher.Date
			continue
		}
		if f == prefix+"Tools" {
			patchee.Tools = patcher.Tools
			continue
		}
		if f == prefix+"Authors" {
			patchee.Authors = patcher.Authors
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"DocumentTypes" {
			patchee.DocumentTypes = patcher.DocumentTypes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMetadata executes a gorm list call
func DefaultListMetadata(ctx context.Context, db *gorm.DB) ([]*Metadata, error) {
	in := Metadata{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MetadataORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MetadataORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Metadata{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MetadataORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MetadataORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MetadataORM) error
}

// DefaultCreateEdge executes a basic gorm create call
func DefaultCreateEdge(ctx context.Context, in *Edge, db *gorm.DB) (*Edge, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EdgeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EdgeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EdgeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EdgeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskEdge patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEdge(ctx context.Context, patchee *Edge, patcher *Edge, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Edge, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"From" {
			patchee.From = patcher.From
			continue
		}
		if f == prefix+"To" {
			patchee.To = patcher.To
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEdge executes a gorm list call
func DefaultListEdge(ctx context.Context, db *gorm.DB) ([]*Edge, error) {
	in := Edge{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EdgeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EdgeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []EdgeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EdgeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Edge{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EdgeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EdgeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EdgeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EdgeORM) error
}

// DefaultCreateExternalReference executes a basic gorm create call
func DefaultCreateExternalReference(ctx context.Context, in *ExternalReference, db *gorm.DB) (*ExternalReference, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExternalReferenceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExternalReferenceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExternalReference(ctx context.Context, in *ExternalReference, db *gorm.DB) (*ExternalReference, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Authority == "" {
		return nil, errors.EmptyIdError
	}
	if ormObj.Comment == "" {
		return nil, errors.EmptyIdError
	}
	if ormObj.Url == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExternalReferenceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExternalReferenceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExternalReferenceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExternalReferenceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExternalReferenceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExternalReference(ctx context.Context, in *ExternalReference, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Authority == "" {
		return errors.EmptyIdError
	}
	if ormObj.Comment == "" {
		return errors.EmptyIdError
	}
	if ormObj.Url == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExternalReferenceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExternalReferenceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExternalReferenceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskExternalReference patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExternalReference(ctx context.Context, patchee *ExternalReference, patcher *ExternalReference, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ExternalReference, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Url" {
			patchee.Url = patcher.Url
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Authority" {
			patchee.Authority = patcher.Authority
			continue
		}
		if f == prefix+"Hashes" {
			patchee.Hashes = patcher.Hashes
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExternalReference executes a gorm list call
func DefaultListExternalReference(ctx context.Context, db *gorm.DB) ([]*ExternalReference, error) {
	in := ExternalReference{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("authority, comment, url")
	ormResponse := []ExternalReferenceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExternalReferenceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ExternalReference{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExternalReferenceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExternalReferenceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExternalReferenceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExternalReferenceORM) error
}

// DefaultCreatePerson executes a basic gorm create call
func DefaultCreatePerson(ctx context.Context, in *Person, db *gorm.DB) (*Person, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PersonORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPerson(ctx context.Context, in *Person, db *gorm.DB) (*Person, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PersonORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PersonORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PersonORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePerson(ctx context.Context, in *Person, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PersonORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PersonORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePersonSet(ctx context.Context, in []*Person, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PersonORM{})).(PersonORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PersonORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PersonORM{})).(PersonORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PersonORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Person, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Person, *gorm.DB) error
}

// DefaultStrictUpdatePerson clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePerson(ctx context.Context, in *Person, db *gorm.DB) (*Person, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePerson")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PersonORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Model(&ormObj).Association("Contacts").Replace(ormObj.Contacts); err != nil {
		return nil, err
	}
	ormObj.Contacts = nil
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PersonORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPerson executes a basic gorm update call with patch behavior
func DefaultPatchPerson(ctx context.Context, in *Person, updateMask *field_mask.FieldMask, db *gorm.DB) (*Person, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Person
	var err error
	if hook, ok := interface{}(&pbObj).(PersonWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(PersonWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPerson(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PersonWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePerson(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PersonWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PersonWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Person, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Person, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Person, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Person, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPerson executes a bulk gorm update call with patch behavior
func DefaultPatchSetPerson(ctx context.Context, objects []*Person, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Person, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Person, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPerson(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPerson patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPerson(ctx context.Context, patchee *Person, patcher *Person, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Person, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"IsOrg" {
			patchee.IsOrg = patcher.IsOrg
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Url" {
			patchee.Url = patcher.Url
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
		if f == prefix+"Contacts" {
			patchee.Contacts = patcher.Contacts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPerson executes a gorm list call
func DefaultListPerson(ctx context.Context, db *gorm.DB) ([]*Person, error) {
	in := Person{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PersonORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Person{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PersonORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PersonORM) error
}

// DefaultCreateTool executes a basic gorm create call
func DefaultCreateTool(ctx context.Context, in *Tool, db *gorm.DB) (*Tool, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ToolORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ToolORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTool(ctx context.Context, in *Tool, db *gorm.DB) (*Tool, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Name == "" {
		return nil, errors.EmptyIdError
	}
	if ormObj.Vendor == "" {
		return nil, errors.EmptyIdError
	}
	if ormObj.Version == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ToolORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ToolORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ToolORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ToolORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ToolORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTool(ctx context.Context, in *Tool, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Name == "" {
		return errors.EmptyIdError
	}
	if ormObj.Vendor == "" {
		return errors.EmptyIdError
	}
	if ormObj.Version == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ToolORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ToolORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ToolORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskTool patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTool(ctx context.Context, patchee *Tool, patcher *Tool, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Tool, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTool executes a gorm list call
func DefaultListTool(ctx context.Context, db *gorm.DB) ([]*Tool, error) {
	in := Tool{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("name, vendor, version")
	ormResponse := []ToolORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ToolORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tool{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ToolORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ToolORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ToolORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ToolORM) error
}

// DefaultCreateDocumentType executes a basic gorm create call
func DefaultCreateDocumentType(ctx context.Context, in *DocumentType, db *gorm.DB) (*DocumentType, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTypeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTypeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DocumentTypeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTypeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskDocumentType patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDocumentType(ctx context.Context, patchee *DocumentType, patcher *DocumentType, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DocumentType, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDocumentType executes a gorm list call
func DefaultListDocumentType(ctx context.Context, db *gorm.DB) ([]*DocumentType, error) {
	in := DocumentType{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTypeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DocumentTypeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []DocumentTypeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DocumentTypeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DocumentType{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DocumentTypeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTypeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DocumentTypeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DocumentTypeORM) error
}

// DefaultCreateNodeList executes a basic gorm create call
func DefaultCreateNodeList(ctx context.Context, in *NodeList, db *gorm.DB) (*NodeList, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NodeListORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNodeList(ctx context.Context, in *NodeList, db *gorm.DB) (*NodeList, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NodeListORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NodeListORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NodeListORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNodeList(ctx context.Context, in *NodeList, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NodeListORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NodeListORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNodeListSet(ctx context.Context, in []*NodeList, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NodeListORM{})).(NodeListORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NodeListORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NodeListORM{})).(NodeListORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NodeListORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NodeList, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NodeList, *gorm.DB) error
}

// DefaultStrictUpdateNodeList clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNodeList(ctx context.Context, in *NodeList, db *gorm.DB) (*NodeList, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNodeList")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NodeListORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEdges := EdgeORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterEdges.NodeListId = new(string)
	*filterEdges.NodeListId = ormObj.Id
	if err = db.Where(filterEdges).Delete(EdgeORM{}).Error; err != nil {
		return nil, err
	}
	filterNodes := NodeORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterNodes.NodeListId = new(string)
	*filterNodes.NodeListId = ormObj.Id
	if err = db.Where(filterNodes).Delete(NodeORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NodeListORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNodeList executes a basic gorm update call with patch behavior
func DefaultPatchNodeList(ctx context.Context, in *NodeList, updateMask *field_mask.FieldMask, db *gorm.DB) (*NodeList, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NodeList
	var err error
	if hook, ok := interface{}(&pbObj).(NodeListWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNodeList(ctx, &NodeList{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NodeListWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNodeList(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NodeListWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNodeList(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NodeListWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NodeListWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NodeList, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NodeListWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NodeList, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NodeListWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NodeList, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NodeListWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NodeList, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNodeList executes a bulk gorm update call with patch behavior
func DefaultPatchSetNodeList(ctx context.Context, objects []*NodeList, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NodeList, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NodeList, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNodeList(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNodeList patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNodeList(ctx context.Context, patchee *NodeList, patcher *NodeList, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NodeList, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Nodes" {
			patchee.Nodes = patcher.Nodes
			continue
		}
		if f == prefix+"Edges" {
			patchee.Edges = patcher.Edges
			continue
		}
		if f == prefix+"RootElements" {
			patchee.RootElements = patcher.RootElements
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNodeList executes a gorm list call
func DefaultListNodeList(ctx context.Context, db *gorm.DB) ([]*NodeList, error) {
	in := NodeList{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NodeListORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NodeListORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NodeList{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NodeListORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NodeListORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NodeListORM) error
}
